<board>
1. write 화면 보여주기(views-> write.jsp(이제 .do 빼고 write라고만 써도 된다)
-> 왜?
웹 페이지는 .jsp(java), .php(c), asp(c#)확장자로 대부분 끝이 난다.
do는 jsp에서 사용하는 가상의 주소
어노테이션을 이용해서 가상의 주소를 받아 자바 파일에서 처리한다.
페이지를 돌려줄 때는 get방식이나 post 방식으로 원하는 jsp 파일을 호출한다.

가상의 주소를 사용하면 사용자는 파일의 실제 경로를 알 수 없으므로 보안에 도움이 되고
소스보기를 해도 소스는 볼 수 있지만 파일의 이름과 경로는 알 수 없다.

흐름>
1) jsp 페이지에서 do가 링크되어있는 요소를 클릭하면
2) 이동하는 페이지를 웹 서버에서 .do가 있는 java 파일을 확인하고
3) .do를 사용하는 어노테이션을 가진 메소드로 이동해서 처리
4) 이후 메소드 안에서 지정해놓은 jsp파일로 이동


write에서 글 쓰고 submit 버튼 누르면 BoardController로 이동


2. BoardController 클래스
Controller
롬북을 설치하면 final이 붙은 멤버변수를 생성자 생성해 종속 객체를 만들어준다.
(setter로 생성하는 방법도 있지만 요즘은 생성자로 생성하는 것이 유행이다.)
이때 추가해야 하는 어노테이션
@Controller
@RequireArgsConstructor
(만약 공통으로 추가해야 하는 경로가 있다면 @RequestMapping()에 추가할 경로 써준다.)

로그 찍을 때 사용하는 클래스 
private static final Logger logger = LoggerFactory.getLogger(BoardController.class);

private final BoardService boardService; 
-> 자동으로 BoardService 객체 생성해준다.

화면 띄우기 get메서드 생성(핸들러)
-> 이제 메서드 이름은 중요하지 X
@GetMapping("/write")-> 어디서 오는지 write.jsp에서 submit을 눌렀을 때 value가 /board/write
public String write_get(){
-> 단순 view만 보여주기 때문에 파라미터 없음, 적용할 DB없음, 결과 처리 없음 화면만 return하면 된다.
그치만 혹시 모르니 로그는 꼭 찍어준다!!!
	
	//1.
	logger.info("게시판 등록 화면");
	//2.
	//3.
	//4.
	return "board/write";
	->application.properties에 앞부분은 /WEB-INF/views/
 	  뒷부분은 .jsp를 붙여주기 때문에 / 안붙여도 된다.(붙여도 되긴 함)

}

글 등록하기 POST 메서드 생성(핸들러)
@PostMapping("/write")
public String write_post(@ModelAttribute BoardVo vo){

	/*Model
	
	 model은 객체
	view의 이름과 view를 렌더링할 때 필요
	map으로 되어있기 대문에 controller에서 view에 필요한 데이터를 key, value로 넣어줌
	request.setAttribute()와 비슷한 역할
	객체에 담을 때는 model.addAttribute("key", value)사용
	*/

	/*@ModelAttribute
	
	요청 파라미터를 받아서 필요한 객체를 만들고 그 객체에 값을 넣어주어야 함
	RequestParam을 사용해서 값 받고, set 이용해서 값 셋팅하지만 ModelAttribute를 쓰면 
	이 과정을 자동으로 해준다.

	
 	- ModelAttribute 어노테이션이 붙은 객체를 자동으로 생성
 	- 지정되는 클래스는 빈 클래스여야 한다
 	- 클래스는 beans 클래스여야 하며 getter와 setter가 있어야 한다.

 	- 생성된 오브젝트에 HTTP로 넘어온 값들을 자동으로 바인딩

 	- 어노테이션이 붙은 객체는 자동으로 Model 객체에 추가되고 .jsp 뷰까지 전달됨
	*/

	//1. 파라미터 읽어오기
	logger.info("글 등록 화면 - 파라미터 vo = " + vo);

	//2.DB작업
	-> config.mybatis.mapper.oracle에 매퍼xml로 가서 sql 구문 추가해준다.
	글 등록이므로 insert
	<insert id = "DAO 메서드 이름" ParameterType = "BoardVo">
		<selectKey KeyProperty = "no" order = "BEFORE" resultType = "int">
		->sql 쿼리문에서 insert 할 때 자동 생성키 그대로 객체로 받아와 사용해야 하는 경우
		(자동 생성키를 별도의 SQL 수행 없이 바로 사용하고 싶을 때) 
			시퀀스 생성 구문
			select board_seq.nextval from dual
		</selectKey>
		이후 insert 구문 입력
		insert into board(no, name, pwd, title, email, content)
		values(#{no}, #{name}, #{pwd}, #{title}, #{email}, #{content})
		->여기서 no는 위에서 시퀀스로 생성했기 때문에 변수로 선언해도 된다.
		다른 입력값들은 inputType name을 대소문자 구별해 정확히 입력한다.
	</insert>

	매핑 구문 완료했으면 메서드 이름을 그대로 복사해 DAO에 추가한다.
	
	@Mapper라 명시
	public interface BoardDAO
	-> public interface BoardService에 메서드 구현 메서드 붙이기
	(DAO는 매퍼파일과 1:1로 매칭되어야 하지만 Service는 꼭 그런건 아니다!!)
	-> BoardServiceImpl class에서 인터페이스 구현

	@Service
	@RequiredArgsConstructor
	public class BoardServiceImpl implements BoardService(){
		BoardDAO 필요
		private final BoardDAO boardDao;
	}


	=> 다시 BoardController로 돌아와 2번 작업
	int cnt = boardService.insertBoard(vo);
	logger.info("글 등록 완료, cnt = " + cnt);
	//3.결과 처리(딱히 없다)

	//4.페이지 
	return "redirect:/board/list";
}




